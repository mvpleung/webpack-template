{"./":{"url":"./","title":"前言","keywords":"","body":"webpack-template   为懒人准备的 webpack 模版，可以直接用于生产。这里单纯只做webpack构建、打包、代码的组织等，关于React、Vue等配置并不复杂，可以在需要时添加。随着webpack版本的迭代，会将最新的特性加入，持续更新...... 有空就写一点 ~,~  Demo源码：https://github.com/Eleven90/webpack-template 版本 webpack 4 + babel 7 Yarn和NPM的选择？ 通常使用NPM做包管理，但此项目使用Yarn，因为Yarn有：速度快、可离线安装、锁定版本、扁平化等更多优点。 如果需要从npm切换到yarn，或者从yarn切换到npm，请整体移除node_modules目录，及yarn.lock/package-lock.json文件，因yarn和npm两者的策略不同，导致相同的package.json列表安装后的node_modules结构是不同的（虽然这并不会引发bug，但建议在切换时清除后重新install）。 Yarn常用命令 yarn / yarn install // 安装全部（package.json）依赖包 —— npm install yarn run [dev] // 启动scripts命令 yarn add [pkgName] // 安装依赖包（默认安装到dependencies下） —— npm install [pkgName] yarn add [pkgName]@[version] // 安装依赖包，指定版本 —— npm install [pkgName]@[version] yarn add [pkgName] -D // 安装依赖包，指定到devDependencies —— npm install [pkgName] -D yarn remove [pkgName] // 卸载依赖包 —— npm uninstall [pkgName] yarn upgrade [pkgName] // 升级依赖包 —— npm update [pkgName] yarn upgrade [pkgName]@[version] // 升级依赖包，指定版本 参考文档 yarn中文网 yarn安装 —— 预警：如果本机已经安装过NodeJS，使用brew安装yarn时，推荐使用brew install yarn --without-node命令，否则可能导致其它bug。 yarn命令 yarn和npm命令对比 powered by GitbookLast modified time： 2019-07-12 20:57:53 "},"content/entry.html":{"url":"content/entry.html","title":"自动扫描入口js、HTML模版","keywords":"","body":" 正常如果有多个入口，需要在 entry 中，以对象形式将所有入口都配置一遍，html 模版目录也需要 new 很多个 HtmlWebpackPlugin 来配置对应的页面模版，是否可以自动扫描? 无论多少个入口，只管新建，而不用管理入口配置？可以的！ 安装 node 模块 glob ( 扫描文件就靠它了 ) yarn add glob -D const glob = require('glob') 自动扫描获取入口文件、html 模版（统一放在 utils.js 文件里） const fs = require('fs') const path = require('path') const glob = require('glob') const appDirectory = fs.realpathSync(process.cwd()) /** * 获取文件 * @param {String} filesPath 文件目录 * @returns {Object} 文件集合(文件名: 文件路径) */ const getFiles = filesPath => { let files = glob.sync(filesPath) let obj = {} let filePath, basename, extname for (let i = 0; i { let entry = {} for (let name in entries) { entry[name] = entries[name] } return entry } webpack 打包入口 module.exports = { entry: utils.getEntries(), } html 模版自动引入打包资源（区分 dev 和 prod 环境，配置不同，同样抽离到 utils.js 文件更好一些） const HtmlWebpackPlugin = require('html-webpack-plugin') /** * 生成webpack.config.dev.js的plugins下new HtmlWebpackPlugin()配置 * @returns {Array} new HtmlWebpackPlugin()列表 */ const getHtmlWebpackPluginsDev = () => { let htmlWebpackPlugins = [] let setting = null for (let name in templates) { setting = { filename: `${name}.html`, template: templates[name], inject: false, // js插入的位置，true/'head'/'body'/false } // (仅)有入口的模版自动引入资源 if (name in getEntries()) { setting.chunks = [name] setting.inject = true } htmlWebpackPlugins.push(new HtmlWebpackPlugin(setting)) setting = null } return htmlWebpackPlugins } /** * 生成webpack.config.prod.js的plugins下new HtmlWebpackPlugin()配置 * @returns {Array} new HtmlWebpackPlugin()列表 */ const getHtmlWebpackPluginsProd = () => { let htmlWebpackPlugins = [] let setting = null for (let name in templates) { setting = { filename: `${name}.html`, template: templates[name], minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }, inject: false, // js插入的位置，true/'head'/'body'/false } // (仅)有入口的模版自动引入资源 if (name in getEntries()) { setting.chunks = ['manifest', 'vendor', 'common', name] setting.inject = true } htmlWebpackPlugins.push(new HtmlWebpackPlugin(setting)) setting = null } return htmlWebpackPlugins } 将 html-webpack-plugin 解构放到 plugins 里 const utils = require('./utils') ... plugins: { // dev ...utils.getHtmlWebpackPluginsDev(), }, ... ... plugins: { // build ...utils.getHtmlWebpackPluginsProd(), }, ... 完整的 utils.js powered by GitbookLast modified time： 2019-06-29 17:22:36 "},"content/babel/":{"url":"content/babel/","title":"Babel 7 转码","keywords":"","body":"Babel 7 转码 这是最新的 babel 配置，和网上的诸多教程可能有不同，可以自行测试验证有效性。 基础依赖包 yarn add babel-loader@8 @babel/core -D 从 babel7 开始，所有的官方插件和主要模块，都放在了 @babel 的命名空间下。从而可以避免在 npm 仓库中 babel 相关名称被抢注的问题。 在 package.json 同级添加.babelrc 配置文件，先空着。 { \"presets\": [], // 预设 \"plugins\": [] // 插件 } package.json 文件可以声明需要支持到的浏览器版本 package.json 中声明的 browserslist 可以影响到 babel、postcss，babel 是优先读取.babelrc 文件中@babel/preset-env 的 targets 属性，未定义会读取 package.json 中的 browserslist。为了统一，在 package.json 中定义。 package.json 中定义（推荐） \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"not ie 更多定义格式请查看：browserslist .babelrc 中定义（不推荐） { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"chrome\": \"58\", \"ie\": \"11\" } } ] ] } powered by GitbookLast modified time： 2019-06-29 14:52:03 "},"content/babel/preset-env.html":{"url":"content/babel/preset-env.html","title":"@babel/preset-env","keywords":"","body":"基本的语法转换，需要添加预设@babel/preset-env 安装依赖包 yarn add @babel/preset-env -D 添加配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等 } ] ], \"plugins\": [] } Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。转译新的 API，需要借助polyfill方案去解决，使用@babel/polyfill或@babel/plugin-transform-runtime，二选一即可。 powered by GitbookLast modified time： 2019-06-29 16:17:02 "},"content/babel/polyfill.html":{"url":"content/babel/polyfill.html","title":"@babel/polyfill","keywords":"","body":"@babel/polyfill 本质上@babel/polyfill是core-js库的别名，随着core-js@3的更新，@babel/polyfill无法从2过渡到3，所以@babel/polyfill已经被放弃，请查看corejs 3 的更新。 安装依赖包： yarn add @babel/polyfill -D .babelrc 文件写上配置，@babel/polyfill 不用写入配置，会根据useBuiltIns参数去决定如何被调用。 { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\", \"modules\": false, \"corejs\": 2, // 新版本的@babel/polyfill包含了core-js@2和core-js@3版本，所以需要声明版本，否则webpack运行时会报warning，此处暂时使用core-js@2版本（末尾会附上@core-js@3怎么用） } ] ] } 配置参数 modules，\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false，默认值是 auto。用来转换 ES6 的模块语法。如果使用 false，将不会对文件的模块语法进行转化。如果要使用 webpack 中的一些新特性，比如 tree shaking 和 sideEffects，就需要设置为 false，对 ES6 的模块文件不做转化，因为这些特性只对 ES6 的模块有效。 useBuiltIns，\"usage\" | \"entry\" | false，默认值是 false。 false：需要在 js 代码第一行主动 import '@babel/polyfill'，会将@babel/polyfill 整个包全部导入。（不推荐，能覆盖到所有 API 的转译，但体积最大） entry：需要在 js 代码第一行主动 import '@babel/polyfill'，会将 browserslist 环境不支持的所有垫片都导入。（能够覆盖到‘hello‘.includes(‘h‘)这种句法，足够安全且代码体积不是特别大） usage：项目里不用主动 import，会自动将代码里已使用到的、且 browserslist 环境不支持的垫片导入。（但是检测不到‘hello‘.includes(‘h‘)这种句法，对这类原型链上的句法问题不会做转译，书写代码需注意） targets，用来配置需要支持的的环境，不仅支持浏览器，还支持 node。如果没有配置 targets 选项，就会读取项目中的 browserslist 配置项。 loose，默认值是 false，如果 preset-env 中包含的 plugin 支持 loose 的设置，那么可以通过这个字段来做统一的设置。 powered by GitbookLast modified time： 2019-06-29 15:36:30 "},"content/babel/transform-runtime.html":{"url":"content/babel/transform-runtime.html","title":"@babel/plugin-transform-runtime","keywords":"","body":"@babel/plugin-transform-runtime 安装依赖包 yarn add @babel/plugin-transform-runtime -D 如果配置参数 corejs 未设置或为 false，需安装依赖@babel/runtime（这部分代码会被抽离并打包到应用 js 里，所以可以安装在 dependencies 里），仅对 es6 语法转译，而不对新 API 转译。 yarn add @babel/runtime 如果配置参数 corejs 设置为 2，需安装依赖@babel/runtime-corejs2（同上，推荐安装在 dependencies 里。），对语法、新 API 都转译。 yarn add @babel/runtime-corejs2 推荐使用corejs:2，但是，检测不到‘hello‘.includes(‘h‘)这种句法，所以存在一定隐患，书写代码时需注意。 @babel/runtime和@babel/runtime-corejs2这两个库唯一的区别是：corejs2 这个库增加了对 core-js（用来对 ES6 各个语法 polyfill 的库）这个库的依赖，所以在 corejs 为 false 的情况下，只能做语法的转换，并不能 polyfill 任何新 API。 .babelrc 文件写上配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"corejs\": 2 // 推荐 } ] ] } 配置参数 corejs，默认值是 false，只对语法进行转换，不对新 API 进行处理；当设置为 2 的时候，需要安装@babel/runtime-corejs2，这时会对 api 进行处理。 helpers，默认值是 true，用来开启是否使用 helper 函数来重写语法转换的函数。 useESModules，默认值是 false，是否对文件使用 ES 的模块语法，使用 ES 的模块语法可以减少文件的大小。 powered by GitbookLast modified time： 2019-06-29 15:20:29 "},"content/babel/polyfill-or-runtime.html":{"url":"content/babel/polyfill-or-runtime.html","title":"polyfill方案的对比","keywords":"","body":"@babel/polyfill 还是 @babel/plugin-transform-runtime ？ @babel/preset-env + @babel/polyfill可以转译语法、新 API，但存在污染全局问题； @babel/preset-env + @babel/plugin-transform-runtime + @babel/runtime-corejs2，可按需导入，转译语法、新 API，且避免全局污染（babel7 中@babel/polyfill 是@babel/runtime-corejs2 的别名），但是检测不到‘hello‘.includes(‘h‘)这种句法； @babel/polyfill 和@babel/runtime-corejs2 都使用了 core-js(v2)这个库来进行 api 的处理。core-js(v2)这个库有两个核心的文件夹，分别是 library 和 modules。@babel/runtime-corejs2 使用 library 这个文件夹，@babel/polyfill 使用 modules 这个文件夹。 library 使用 helper 的方式，局部实现某个 api，不会污染全局变量； modules 以污染全局变量的方法来实现 api； library 和 modules 包含的文件基本相同，最大的不同是_export.js 这个文件： modules // core-js/modules/_exports.js var global = require('./_global'); var core = require('./_core'); var hide = require('./_hide'); var redefine = require('./_redefine'); var ctx = require('./_ctx'); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; library // core-js/library/_exports.js var global = require('./_global'); var core = require('./_core'); var ctx = require('./_ctx'); var hide = require('./_hide'); var has = require('./_has'); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var IS_WRAP = type & $export.W; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE]; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]; var key, own, out; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; if (own && has(exports, key)) continue; // export native or passed out = own ? target[key] : source[key]; // prevent global pollution for namespaces exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library : IS_WRAP && target[key] == out ? (function (C) { var F = function (a, b, c) { if (this instanceof C) { switch (arguments.length) { case 0: return new C(); case 1: return new C(a); case 2: return new C(a, b); } return new C(a, b, c); } return C.apply(this, arguments); }; F[PROTOTYPE] = C[PROTOTYPE]; return F; // make static versions for prototype methods })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME% if (IS_PROTO) { (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME% if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out); } } }; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; 可以看出，library下的这个$export方法，会实现一个wrapper函数，防止污染全局变量。 例如对Promise的转译，@babel/polyfill和@babel/runtime-corejs2的转译方式差异如下： var p = new Promise(); // @babel/polyfill require(\"core-js/modules/es6.promise\"); var p = new Promise(); // @babel/runtime-corejs2 var _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\"); var _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\")); var a = new _promise.default(); 从上面这个例子可以看出，对于Promise这个api，@babel/polyfill引用了core-js/modules中的es6.promise.js文件，因为是对全局变量进行处理，所以赋值语句不用做处理；@babel/runtime-corejs2会生成一个局部变量_promise，然后把Promise都替换成_promise，这样就不会污染全局变量了。 综合上面的分析，得出结论： 如果是自己的应用： @babel/preset-env + @babel/polyfill 根据useBuiltIns参数确定如何使用@babel/polyfill，具体参数设置总结如下： useBuiltIns设置为entry比较不错，推荐使用。在js代码第一行import '@babel/polyfill'，或在webpack的入口entry中写入模块@babel/polyfill，会将browserslist环境不支持的所有垫片都导入； 能够覆盖到‘hello‘.includes(‘h‘)这种句法，足够安全且代码体积不是特别大！ useBuiltIns设置为usage。项目里不用主动import，会自动将代码里已使用到的、且browserslist环境不支持的垫片导入； 相对安全且打包的js体积不大，但是，通常我们转译都会排除node_modules/目录，如果使用到的第三方包有个别未做好ES6转译，有遇到bug的可能性，并且检测不到‘hello‘.includes(‘h‘)这种句法。 代码书写规范，且信任第三方包的时候，可以使用！ useBuiltIns设置为false比较不错。在js代码第一行import '@babel/polyfill'，或在webpack的入口entry中写入模块@babel/polyfill，会将@babel/polyfill整个包全部导入； 最安全，但打包体积会大一些，一般不选用。 需要安装的全部依赖： yarn add babel-loader@8 @babel/core @babel/preset-env -D yarn add @babel/polyfill .babelrc配置文件 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, // 推荐 \"useBuiltIns\": \"entry\", // 推荐 \"corejs\": 2, // 新版本的@babel/polyfill包含了core-js@2和core-js@3版本，所以需要声明版本，否则webpack运行时会报warning，此处暂时使用core-js@2版本（末尾会附上@core-js@3怎么用） } ] ], \"plugins\": [] } 如果是开发第三方类库： @babel/preset-env + @babel/plugin-transform-runtime + @babel/runtime-corejs2（或者，不做转码处理，提醒使用者自己做好兼容处理也可以）。 需要安装的全部依赖： yarn add babel-loader@8 @babel/core @babel/preset-env @babel/plugin-transform-runtime -D yarn add @babel/runtime-corejs2 .babelrc配置文件 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"corejs\": 2 // 推荐 } ] ] } 参考文档 babel polyfill 和 runtime 浅析 Babel + Webpack 配置前端项目 powered by GitbookLast modified time： 2019-07-29 13:20:48 "},"content/babel/proposal.html":{"url":"content/babel/proposal.html","title":"提案级别的插件","keywords":"","body":" babel 官方认为，把不稳定的 stage0-3 作为一种预设是不太合理的，@babel/preset-env、@babel/polyfill等只支持到stage-4级别，因此 babel 新版本废弃了 stage 预设，转而让用户自己选择使用哪个 proposal 特性的插件，这将带来更多的明确性（用户无须理解 stage，自己选的插件，自己便能明确的知道代码中可以使用哪个特性）。 所有建议特性的插件，都改变了命名规范，即类似 @babel/plugin-proposal-function-bind 这样的命名方式来表明这是个 proposal 阶段特性。 所以，处于建议阶段的特性，基本都已从@babel/preset-env、@babel/polyfill等包中被移除，需要自己去另外安装对应的 preset、plugin，（一般你能找到的名称里有 proposal 字样的包，需要自己在@babel/preset-env、@babel/plugin-transform-runtime以外做配置）。 各个级别当前可以选用的 proposal 插件大概如下（传送门）： { \"plugins\": [ // Stage 0 \"@babel/plugin-proposal-function-bind\", // Stage 1 \"@babel/plugin-proposal-export-default-from\", \"@babel/plugin-proposal-logical-assignment-operators\", [\"@babel/plugin-proposal-optional-chaining\", { \"loose\": false }], [\"@babel/plugin-proposal-pipeline-operator\", { \"proposal\": \"minimal\" }], [\"@babel/plugin-proposal-nullish-coalescing-operator\", { \"loose\": false }], \"@babel/plugin-proposal-do-expressions\", // Stage 2 [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], \"@babel/plugin-proposal-function-sent\", \"@babel/plugin-proposal-export-namespace-from\", \"@babel/plugin-proposal-numeric-separator\", \"@babel/plugin-proposal-throw-expressions\", // Stage 3 \"@babel/plugin-syntax-dynamic-import\", \"@babel/plugin-syntax-import-meta\", [\"@babel/plugin-proposal-class-properties\", { \"loose\": false }], \"@babel/plugin-proposal-json-strings\" ] } powered by GitbookLast modified time： 2019-06-29 15:39:16 "},"content/babel/decorators.html":{"url":"content/babel/decorators.html","title":"装饰器语法支持","keywords":"","body":" 安装依赖 yarn add @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties -D .babelrc 增加配置 { \"presets\": [], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", // @babel/plugin-proposal-decorators需要在@babel/plugin-proposal-class-properties之前 { \"legacy\": true // 推荐 } ], [ \"@babel/plugin-proposal-class-properties\", { \"loose\": true // babel编译时，对class的属性采用赋值表达式，而不是Object.defineProperty（更简洁） } ] ] } powered by GitbookLast modified time： 2019-06-29 16:16:24 "},"content/babel/import.html":{"url":"content/babel/import.html","title":"动态导入支持","keywords":"","body":" 安装依赖 yarn add @babel/plugin-syntax-dynamic-import -D .babelrc 文件增加配置 { \"presets\": [], \"plugins\": [ \"@babel/plugin-syntax-dynamic-import\", ] } powered by GitbookLast modified time： 2019-06-29 16:17:27 "},"content/babel/corejs3.html":{"url":"content/babel/corejs3.html","title":"corejs 3 的更新","keywords":"","body":" 以上是core-js@2的配置，而core-js@3的更新，带来了新的变化，@babel/polyfill无法提供core-js@2向core-js@3过渡，所以现在有新的方案去替代@babel/polyfill，（需要Babel版本升级到7.4.0及以上），详细可以阅读官方的几篇文档： 作者的官方阐述 Babel 7.4.0版本的更新内容，及官方的升级建议 core-js@2向core-js@3升级，官方的Pull request @babel/preset-env也因core-js@3的原因，需要配置corejs参数，否则webpack运行时会报warning； @babel/polyfill不必再安装，转而需要依靠core-js和regenerator-runtime（详细原因请看作者的阐述），替代方案用法如下： 安装依赖 yarn add babel-loader@8 @babel/core @babel/preset-env -D yarn add core-js regenerator-runtime .babelrc配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等 \"useBuiltIns\": \"entry\", // browserslist环境不支持的所有垫片都导入 // https://babeljs.io/docs/en/babel-preset-env#usebuiltins // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md \"corejs\": { \"version\": 3, // 使用core-js@3 \"proposals\": true, } } ] ], \"plugins\": [] } js代码里取代原先的import '@babel/polyfill'，做如下修改： import \"core-js/stable\" import \"regenerator-runtime/runtime\" 而@babel/plugin-transform-runtime，也随着core-js@3有更新： 安装依赖 yarn add babel-loader@8 @babel/core @babel/preset-env @babel/plugin-transform-runtime -D yarn add @babel/runtime-corejs3 .babelrc文件配置 { \"presets\": [ [ \"@babel/preset-env\", { \"modules\": false, } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"corejs\": { \"version\": 3, \"proposals\": true }, \"useESModules\": true } ] ] } powered by GitbookLast modified time： 2019-06-29 18:18:03 "},"content/style.html":{"url":"content/style.html","title":"CSS样式的处理","keywords":"","body":"less、postcss 需要安装的依赖包 yarn add less less-loader css-loader style-loader postcss-loader postcss-preset-env postcss-import cssnano postcss-safe-parser mini-css-extract-plugin -D 过去版本的autoprefixer、postcss-cssnext已内置在postcss-preset-env内。 配置 默认会将 css 一起打包到 js 里，借助 mini-css-extract-plugin 将 css 分离出来并自动在生成的 html 中 link 引入（过去版本中的 extract-text-webpack-plugin 已不推荐使用）。 const MiniCssExtractPlugin = require('mini-css-extract-plugin') loader { test: /\\.(less|css)$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'less-loader'], } // 在启用dev-server时，mini-css-extract-plugin插件不能使用contenthash给文件命名 => 所以本地起dev-server服务调试时，使用style-loader // USE_HMR是自定义的环境变量，意思是是否使用了热替换中间件 const styleLoader = process.env.USE_HMR ? 'style-loader' : MiniCssExtractPlugin.loader // 通过其他合适的方式判断是否为本地调试环境也一样，自由选择。 const styleLoader = process.env.BUILD_ENV === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader { test: /\\.(less|css)$/, use: [styleLoader, 'css-loader', 'postcss-loader', 'less-loader'], }, plugin // 单独使用link标签加载css并设置路径，相对于output配置中的publickPath new MiniCssExtractPlugin({ filename: 'static/css/[name].[contenthash:7].css', // 注意这里使用的是contenthash，否则任意的js改动，打包时都会导致css的文件名也跟着变动。 chunkFilename: 'static/css/[name].[contenthash:7].css', }) PostCSS 本身不会对你的 CSS 做任何事情, 你需要安装一些 plugins（postcss GitHub 文档） 才能开始工作。 在 package.json 同级目录，新建 postcss.config.js 文件: module.exports = { // parser: 'sugarss', // 是一个以缩进为基础的语法，类似于 Sass 和 Stylus，https://github.com/postcss/sugarss plugins: { 'postcss-import': {}, 'postcss-preset-env': {}, 'cssnano': {}, 'postcss-flexbugs-fixes': {}, } } 常用的插件: cssnano —— 会压缩你的 CSS 文件来确保在开发环境中下载量尽可能的小 其它有用的插件: postcss-pxtorem —— px 单位自动转换 rem postcss-assets —— 插件用来处理图片和 SVG, 类似 url-load postcss-sprites —— 自动合成雪碧图，提供了细致的配置方法、插件去自定义控制（看上去略复杂） img-loader —— 自动压缩图片，参数控制压缩比率 postcss-font-magician —— 使用自定义字体时, 自动搞定@font-face 声明 Less 是预处理，而 PostCSS 是后处理，基本支持 less 等预处理器的功能，自动添加浏览器厂商前缀向前兼容，允许书写下一代 css 语法 ，可以在编译时去除冗余的 css 代码，PostCSS 声称比预处理器快 3-30 倍，因为 PostCSS，可能我们要放弃 less/sass/stylus 了。 powered by GitbookLast modified time： 2019-08-06 23:00:21 "},"content/media.html":{"url":"content/media.html","title":"图片、字体、多媒体等资源的处理","keywords":"","body":" css或js 中引入的图片、字体、多媒体等静态资源，统一使用 url-loader 处理。 配置了 url-loader 以后，webpack 编译时可以自动将小文件转成 base64 编码，减少网络请求。如果不需要将小文件转成 base64 ，也可以用 file-loader 替换 url-loader。 安装依赖包 url-loader 内部会自动调用 file-loader，所以仍然需要安装。 yarn add url-loader file-loader -D 添加配置 // 处理图片(file-loader来处理也可以，url-loader更适合图片) { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: 'static/assets/images/[name].[hash:7].[ext]', }, }, // 处理多媒体文件 { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: 'static/assets/media/[name].[hash:7].[ext]', }, }, // 处理字体文件 { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: 'static/assets/fonts/[name].[hash:7].[ext]' } }, js中使用到静态资源，需要通过 import、require 导入再使用，才会被处理。 import img from 'xxx/xxx/123.jpg' 或 let img = require('xxx/xxx/123.jpg') 对于直接在 html 页面中通过标签引入的图片或其它静态资源，即使配置了 url-loader，webpack也不会去处理它们，可以使用 html-loader 处理。 安装依赖包 yarn add html-loader -D 添加配置 // html中引用的静态资源在这里处理,默认配置参数attrs=img:src,处理图片的src引用的资源. { test: /\\.html$/, loader: 'html-loader', options: { // 除了img的src,还可以继续配置处理更多html引入的资源(不能在页面直接写路径,又需要webpack处理怎么办?先require再js写入). attrs: ['img:src', 'img:data-src', 'audio:src'], minimize: false, removeComments: true, collapseWhitespace: false } } 静态资源的访问路径问题 经过上面的处理，静态资源处理基本没有问题了，webpack 编译时将会将文件打包到你指定的生成目录，但是不同位置的路径url会是一个问题。全部通过绝对路径访问即可，在 output 下的 publicPath 填上适当的 server 端头，来保证所有静态资源文件能被访问到，具体要根据服务器部署的目录结构来做修改。 output: { path: path.resolve(__dirname, 'dist'), // 输出目录的配置，模板、样式、脚本、图片等资源的路径配置都相对于它 publicPath: '/', // 模板、样式、脚本、图片等资源对应的server上的路径 } powered by GitbookLast modified time： 2019-06-29 17:52:00 "},"content/dev-server.html":{"url":"content/dev-server.html","title":"配置dev-server","keywords":"","body":"webpack-dev-server 安装依赖包 yarn add webpack-dev-server -D 常用配置 devServer: { contentBase: path.join(__dirname, 'static'), // 告诉服务器从哪里提供内容(默认当前工作目录) openPage: 'views/index.html', // 指定默认启动浏览器时打开的页面 index: 'views/index.html', // 指定首页位置 watchContentBase: true, // contentBase下文件变动将reload页面(默认false) host: 'localhost', // 默认localhost,想外部可访问用'0.0.0.0' port: 8080, // 默认8080 inline: true, // 可以监控js变化 hot: true, // 热启动 open: true, // 启动时自动打开浏览器（指定打开chrome，open: 'Google Chrome'） compress: true, // 一切服务都启用gzip 压缩 disableHostCheck: true, // true：不进行host检查 quiet: false, https: false, clientLogLevel: 'none', stats: { // 设置控制台的提示信息 chunks: false, children: false, modules: false, entrypoints: false, // 是否输出入口信息 warnings: false, performance: false, // 是否输出webpack建议（如文件体积大小） }, historyApiFallback: { disableDotRule: true, }, watchOptions: { ignored: /node_modules/, // 略过node_modules目录 }, proxy: { // 接口代理（这段配置更推荐：写到package.json，再引入到这里） \"/api-dev\": { \"target\": \"http://api.test.xxx.com\", \"secure\": false, \"changeOrigin\": true, \"pathRewrite\": { // 将url上的某段重写（例如此处是将 api-dev 替换成了空） \"^/api-dev\": \"\" } } }, before(app) { }, } 根据目录结构的不同，contentBase、openPage 参数要配置合适的值，否则运行时应该不会立刻访问到你的首页; 同时要注意你的 publicPath，静态资源打包后生成的路径是一个需要思考的点，这与你的目录结构有关。 package.json 添加运行命令 \"scripts\": { \"dev\": \"cross-env BUILD_ENV=development webpack-dev-server --mode development --colors --profile\" } 不同操作系统传递参数的形式不一样，cross-env 可以抹平这个平台差异。 雕虫小技： dev-server 的代码通常在内存中，但也可以写入硬盘，产出实体文件： { writeToDisk: true, } 通常可以用于代理映射文件调试，编译时会产出许多带 hash 的js 文件，不带 hash 的文件同样也是实时编译的。 有的时候，启动服务时，想要默认使用本地的 ip 地址打开： { disableHostCheck: true, // true：不进行host检查 // useLocalIp: true, // 建议不在这里配置 // host: '0.0.0.0', // 建议不在这里配置 } 同时还需要将 host 配置为 0.0.0.0，这个配置建议在 scripts 命令中追加，而非在配置中写死，否则将来不想要这种方式往回改折腾，取巧一点，配个新命令： \"dev-ip\": \"yarn run dev --host 0.0.0.0 --useLocalIp\", 有时启动的时候希望是指定的调试域名，例如：local.test.baidu.com： { open: true, public: 'local.test.baidu.com:8080', // 需要带上端口 port: 8080, } 同时需要将 127.0.0.1 修改为指定的 host，可以借助 iHost 等工具去修改，各个工具大同小异，格式如下： 127.0.0.1 local.test.baidu.com 服务启动后将自动打开 local.test.baidu.com:8080 访问 dev-server 调试时，启动 gzip 压缩： { compress: true, } powered by GitbookLast modified time： 2019-09-23 21:39:06 "},"content/alias.html":{"url":"content/alias.html","title":"模块配置别名、扩展名","keywords":"","body":"模块配置别名、扩展名 给模块配置扩展名，导入时即可省略文件后缀，webpack将自动完成查找。 给模块或目录配置别名，即可在导入时避免书写冗长的引入路径，如：import $ from 'utils/zepto.min'；某个自己写的通用插件，配置别名为xx后，即可：import xx from 'xx'。 示例代码： const paths = require('./paths') module.exports = { ... resolve: { // 配置模块扩展名 extensions: ['.js', '.json', '.css', '.less', '.art'], // 配置模块别名或目录别名 alias: { src: paths.appSrc, components: paths.appComponents, // 将路径放到path.js里统一管理，更加推荐 xx: path.resolve(__dirname, 'src/lib/xx.js'), // 给某个模块配置别名 }, }, ... } powered by GitbookLast modified time： 2019-07-10 12:02:09 "},"content/provide.html":{"url":"content/provide.html","title":"全局注入模块，省去到处导入","keywords":"","body":" 通常使用模块，我们需要先import、require该模块，例如：react，我们需要在每个react组件中都import一次，通过webpack.ProvidePlugin，我们可以省去这种重复劳动，不必在组件中单独导入。 module.exports = { ... plugins: [ // 大量需要使用到的模块，在此处一次性注入，避免到处import/require。 new webpack.ProvidePlugin({ React: 'react', Zepto: 'zepto', }), ], ... } powered by GitbookLast modified time： 2019-07-10 12:18:58 "},"content/define.html":{"url":"content/define.html","title":"注入应用的全局变量","keywords":"","body":"注入应用的全局变量 process.env是nodejs运行环境下的全局变量，在我们的应用代码（如src目录下的代码）中是无法直接读取到的，如果想要在应用代码中读取到process.env，或者如package.json中的数据，或其它nodejs环境中才有的变量，可以通过webpack.DefinePlugin将它们注入到应用中，将被声明为全局变量，直接读取即可。 如react脚手架，是以这种方式，将所有的process.env变量，全部注入到了应用代码中，所以使用react脚手架搭建的应用，可以直接通过process.env.读取到环境变量。 通常我们可以通过这种方式，去配置、读取系统的版本号；通过自己定义环境变量，注入到应用中，去区分编译环境。 示例代码： module.exports = { ... plugins: [ // 应用中需要的process.env变量，在此注入才能使用。 new webpack.DefinePlugin({ BUILD_ENV: JSON.stringify(process.env.BUILD_ENV), // 编译环境（development/test/production） }), ], ... } powered by GitbookLast modified time： 2019-07-10 12:18:14 "},"content/module.html":{"url":"content/module.html","title":"在 webpack 中引入未模块化的库","keywords":"","body":"如何在 webpack 中引入未模块化的库，如：Zepto script-loader 把我们指定的模块 JS 文件转成纯字符串，exports-loader 将需要的 js 对象 module.exports 导出，以支持 import 或 require 导入。 安装依赖包 yarn add script-loader exports-loader -D 配置 { test: require.resolve('zepto'), loader: 'exports-loader?window.Zepto!script-loader' } 以上是正常处理一个 \"可以 npm 安装，但又不符合 webpack 模块化规范\" 的库，例如其它库 XX，处理后可以直接 import xx from XX 后使用; 但是，zepto 有点特殊，默认 npm 安装的包或者从 github clone 的包，都是仅包含 5 个模块，其它如常用的 touch 模块是未包含的，想要正常使用还需做得更多。 怎样拿到一个包含更多模块的 zepto 包 ？ a) 打包出一个包含更多需要模块的 zepto 包 从 github clone 官方的包下来, 找到名为 make 的文件 ( 在 package.json 同级目录 ),， 用记事本打开，找到这一行 modules = (env['MODULES'] || 'zepto event ajax form ie').split(' ')，应该是在第 41 行，手动修改加入你想要引入的模块，然后保存; b) 在 make 文件同级目录 => 右键打开终端或 git bash => 敲 yarn add 安装 zepto 源码需要的 node 包 ( 这里你应当是已经已安装过 nodejs 了，如果没有，安装好后再做这一步 )，等待安装结束. c) 在刚才打开的 终端/git bash 敲命令 npm run-script dist，如果没有报错，你应该在这个打开的文件夹里可以看到生成了一个文件夹 dist，打开它，包含新模块的 zepto 包就在这了，Over ! 拿到新的 zepto 包后，建议放到自己的 src 下 lib 目录( 第三方工具包目录 )，不再通过 npm 的方式去安装和更新 zepto 了 ( 因为将来 npm update 后的 zepto 又将缺少模块，将来别人也会出现误操作 )；现在开始对这个放在 lib 目录下的 zepto.min.js 进行处理： 通过 script-loader、exports-loader 转成符合 webpack 模块化规范的包 { // # require.resolve()是nodejs用来查找模块位置的方法,返回模块的入口文件 test: require.resolve('./src/js/lib/zepto.min.js'), loader: 'exports-loader?window.Zepto!script-loader' } 给模块配置别名 resolve: { alias: { 'zepto': path.resolve(__dirname, './src/js/lib/zepto.min.js') } } 自动加载模块，不再到处 import 或 require new webpack.ProvidePlugin({ $: 'zepto', Zepto: 'zepto', }) 大功告成，现在使用 zepto 跟你使用 jquery 或其它 node 包是一样的开发体验了！ 以上，演示的是对于一个第三方库( 不能 npm 安装，也不符合 webpack 模块规范 )，如何去处理，达到和正常 npm 安装一样的开发体验，仅就 zepto 来说，npm 库有符合 webpack 规范的不同版本 (zepto-webpack，或 zepto-modules)，有需要可以试试。平时意图使用某个包，先去NPM 官网搜一搜比较好。 powered by GitbookLast modified time： 2019-06-29 18:01:00 "},"content/prune.html":{"url":"content/prune.html","title":"打包时排除应用中的某些模块","keywords":"","body":" 某些时候，应用中依赖了某些模块，但希望将这些模块独立通过CDN引入，以减小包的体积，所以不必将这些模块打包，例如：jQuery。特定场景下，这个功能会有用武之地！webpack提供了 externals 可以来配置，打包时将此模块排除，且不用修改其它任何代码。 module.exports = { ... output: { ... }, externals: { jquery: \"jQuery\" }, ... } powered by GitbookLast modified time： 2019-06-29 18:02:40 "},"content/library.html":{"url":"content/library.html","title":"打包js库时的应用","keywords":"","body":"webpack打包js库 通常打包js库会选择 rollup，但是 webpack 同样可以做到，如果是需要对 css、图片等有较多应用的 js 库，webpack 会有更多优势。 配置 module.exports = { ... entry: { sdk: 'xxxxxxx.js', }, output: { ... library: '[name]', // 被挂载到全局对象（window、global）上的变量名称 libraryTarget: 'umd', // 模块规范，umd 包含全部模块规范 libraryExport: 'default', // 导出的对象，默认是 default umdNamedDefine: true, // 会对 UMD 的构建过程中的 AMD 模块进行命名，否则就使用匿名的 define }, ... } umd —— 打包出所有环境都可以使用的包 代码里导出 export default { a: xxxx, b: xxxx, c: xxxx, } build打包后的js，将支持import、requrie导入，script标签引入，可以通过window.sdk使用等： // import import { a, b, c } from '........js' // require const anything = require('........js') // window window.sdk window.sdk.a // node global.sdk global.sdk.a 参考文档： 怎样打包一个library？ 一次打包暴露多个库 powered by GitbookLast modified time： 2019-06-29 18:07:59 "},"content/node-server.html":{"url":"content/node-server.html","title":"配置 node express 服务","keywords":"","body":"配置 node express 服务 某些时候可能希望本地访问打包后的资源，可以配置一个 node express 服务完成。当然，你也可以通过它代理接口，mock数据（虽然不必如此）。 新建 prod.server.js 文件，放到 package.json 同级目录 let express = require('express') let compression = require('compression') let app = express() let port = 9898 app.use(compression()) app.use(express.static('./static/')) module.exports = app.listen(port, function(err) { if (err) { console.log(err) return } console.log('Listening at http://localhost:' + port + '\\n') }) 运行命令 node prod.server.js 访问路径 localhost:9898/views/ powered by GitbookLast modified time： 2019-06-29 18:10:35 "},"content/http-server.html":{"url":"content/http-server.html","title":"配置 http-server","keywords":"","body":" 比自己配置一个 node express 服务更简洁的方式，去访问打包后的资源，可以使用 http-server 。 安装依赖 yarn add http-server -D package.json 配置命令 \"scripts\": { \"http-server\": \"http-server dist\" } 访问路径 localhost:8080 或 http://127.0.0.1:8080 powered by GitbookLast modified time： 2019-06-29 18:11:50 "},"content/eslint.html":{"url":"content/eslint.html","title":"集成eslint","keywords":"","body":" 安装依赖 yarn add eslint eslint-loader eslint-friendly-formatter babel-eslint -D eslint-friendly-formatter，指定终端中输出eslint提示信息的格式。 增加配置 { test: /\\.js$/, enforce: 'pre', loader: 'eslint-loader', include: [paths.appSrc], exclude: [ /node_modules/, ], options: { formatter: require('eslint-friendly-formatter'), }, }, package.json文件同级增加文件.eslintrc.js module.exports = { \"root\": true, \"parserOptions\": { \"sourceType\": \"module\", }, \"parser\": \"babel-eslint\", // eslint未支持的js新特性先进行转换 \"env\": { \"browser\": true, \"es6\": true, \"node\": true, \"shared-node-browser\": true, \"commonjs\": true, }, \"globals\": { // 设置全局变量（false：不允许重写；） \"BUILD_ENV\": false, }, \"extends\": \"eslint:recommended\", // 使用官方推荐规则，使用其他规则，需要先install，再指定。 \"rules\": { // 定义检查规则 } } 配置项含义： root 限定配置文件的使用范围 parser 指定eslint的解析器 parserOptions 设置解析器选项 extends 指定eslint规范 plugins 引用第三方的插件 env 指定代码运行的宿主环境 rules 启用额外的规则或覆盖默认的规则 globals 声明在代码中的自定义全局变量 ESLint官方的rules列表 如果有需要跳过检查的文件/文件夹，有两种途径可以实现： 新建.eslintignore文件 /node_modules 直接在文件、代码里加标识，详细请看：官方文档的忽略规则 参考文档 webpack引入eslint详解 babel-eslint powered by GitbookLast modified time： 2019-06-29 18:12:32 "},"content/optimize.html":{"url":"content/optimize.html","title":"常见性能优化","keywords":"","body":"常见性能优化 使用happypack来优化，多进程运行编译，参考文档： webpack 优化之 HappyPack 实战 happypack 原理解析 使用cache-loader缓存编译结果 DllPlugin拆分基础包 powered by GitbookLast modified time： 2019-06-29 18:13:45 "},"content/reference.html":{"url":"content/reference.html","title":"参考文档","keywords":"","body":"参考文档 webpack 中文文档 —— 直接阅读它非常有用，百度出来的教程 99%都是管中窥豹，只见一斑，会形成误导（不要问我是怎么知道的 -_-）。 NPM 中文文档 基于 webpack 的前端工程化开发之多页站点篇（一） 基于 webpack 的前端工程化开发之多页站点篇（二） webpack 在前端项目中使用心得一二 webpack4配置详解之逐行分析 手摸手，带你用合理的姿势使用 webpack4（上） 手摸手，带你用合理的姿势使用 webpack4（下） 一文读懂 babel7 的配置文件加载逻辑 babel polyfill 和 runtime 浅析 powered by GitbookLast modified time： 2019-06-29 18:14:53 "}}